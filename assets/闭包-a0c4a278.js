import{_ as p}from"./ValaxyMain.vue_vue_type_style_index_0_lang-8e683539.js";import{_ as d,c as u,w as e,o as h,a as l,b as s,d as a,r as t,e as _,p as y}from"./app-d437ec14.js";import"./YunFooter.vue_vue_type_script_setup_true_lang-023ce13c.js";import"./YunCard.vue_vue_type_style_index_0_lang-d177144b.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang-350ab47c.js";const dl=JSON.parse('{"title":"闭包","description":"","frontmatter":{"title":"闭包","date":"2023-03-17T00:00:00.000Z","updated":"2022-03-18T00:00:00.000Z","cover":"https://fastly.jsdelivr.net/gh/YunYouJun/cdn/img/bg/astronaut.webp","categories":["JavaScript","知识点"],"tags":["闭包"]},"headers":[{"level":2,"title":"1.闭包（closure）和对象","slug":"_1-闭包（closure）和对象","link":"#_1-闭包（closure）和对象","children":[{"level":3,"title":"闭包的描述","slug":"闭包的描述","link":"#闭包的描述","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":3,"title":"相关拓展","slug":"相关拓展","link":"#相关拓展","children":[]}]}],"relativePath":"pages/posts/JavaScript/知识点/闭包.md","path":"/home/runner/work/flying-fish-blog/flying-fish-blog/pages/posts/JavaScript/知识点/闭包.md","lastUpdated":1679288561000}'),r=JSON.parse('{"title":"闭包","description":"","frontmatter":{"title":"闭包","date":"2023-03-17T00:00:00.000Z","updated":"2022-03-18T00:00:00.000Z","cover":"https://fastly.jsdelivr.net/gh/YunYouJun/cdn/img/bg/astronaut.webp","categories":["JavaScript","知识点"],"tags":["闭包"]},"headers":[{"level":2,"title":"1.闭包（closure）和对象","slug":"_1-闭包（closure）和对象","link":"#_1-闭包（closure）和对象","children":[{"level":3,"title":"闭包的描述","slug":"闭包的描述","link":"#闭包的描述","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":3,"title":"相关拓展","slug":"相关拓展","link":"#相关拓展","children":[]}]}],"relativePath":"pages/posts/JavaScript/知识点/闭包.md","path":"/home/runner/work/flying-fish-blog/flying-fish-blog/pages/posts/JavaScript/知识点/闭包.md","lastUpdated":1679288561000}'),D={name:"pages/posts/JavaScript/知识点/闭包.md",data(){return{data:r,frontmatter:r.frontmatter}},setup(){y("pageData",r)}},F={id:"_1-闭包（closure）和对象",tabindex:"-1"},m=l("ul",null,[l("li",null,"共同特性：")],-1),f=l("blockquote",null,[l("p",null,"都可以对一个状态值进行封装和创建行为")],-1),g={id:"闭包的描述",tabindex:"-1"},A=l("p",null,[l("em",null,"为什么要使用闭包？"),s(" 看看AI怎么回答 闭包是一种非常有用的编程技术，它可以帮助我们解决一些常见的问题，例如：")],-1),C=l("ol",null,[l("li",null,"保护变量：闭包可以将变量封装在函数内部，防止外部代码对其进行修改，从而保护变量的安全性。"),l("li",null,"实现私有变量和方法：闭包可以创建私有变量和方法，这些变量和方法只能在函数内部访问，外部代码无法访问，从而实现了数据的封装和隐藏。"),l("li",null,"延迟执行：闭包可以将函数作为参数传递给其他函数，从而实现延迟执行的效果。"),l("li",null,"实现回调函数：闭包可以将函数作为参数传递给其他函数，从而实现回调函数的效果。"),l("li",null,"优化性能：闭包可以避免全局变量的使用，从而减少内存的占用和提高代码的执行效率。 总之，闭包是一种非常有用的编程技术，可以帮助我们解决一些常见的问题，提高代码的可读性、可维护性和性能。")],-1),v=l("hr",null,null,-1),b=l("ul",null,[l("li",null,[l("p",null,"闭包最大特点是：可以突破声明周期和作用域的限制，也就是时间和空间的限制")]),l("li",null,[l("p",null,"突破生命周期：当一个外部函数内嵌一个内部函数是，如果内嵌函数引用了外部函数的变量，这个变量就会突破声明周期的限制，在函数执行后，仍然存在。")]),l("li",null,[l("p",null,"突破作用域的限制：我们可以把一个内部函数返回成一个方法在外部调用")]),l("li",null,[l("p",null,"是函数式编程常用的状态保存和引用手段")])],-1),E=l("p",null,"从表面上看闭包延长了变量的存在时间，让变量可以在声明的作用域之外调用，单从这个方面考虑的话，好像和使用对象没什么区别 可以通过对象来封装一个状态，并且封装一个方法来做用于这个状态值",-1),k=l("p",null,[l("strong",null,"那么问题来了"),s("：既然效果一样，闭包还有什么意义？使用对象不就行了 一个比较好的解释是：")],-1),$=l("blockquote",null,[l("p",null,"它们在隐私（privacy）、状态拷贝（state cloning）和性能（performance）上。还是有差别的，而这些差别在结构性地处理值的问题上，具有不同的优劣势，")],-1),J=l("p",null,"而闭包和对象的区分也将从这几个维度展现出来",-1),S={id:"_1-属性的修改-隐私-privacy",tabindex:"-1"},B=l("p",null,[s("闭包的例子很常见，可以发现，除非通过接口，即外部函数中返回内部函数的方法，否则外部函数内部的值是"),l("strong",null,"对外不可见"),s("的。")],-1),j=l("p",null,[l("em",null,"有什么好处？")],-1),P=l("blockquote",null,[l("p",null,"可以细粒度地控制我们想要暴露或隐藏的属性，以及相关的操作。并非所有的数据希望在函数外部可以随意的获取或者更改")],-1),q=l("p",null,[l("em",null,"为什么要细粒度？"),s(" 这个需要结合具体的使用场景来具体分析： "),l("strong",null,"纯函数和不可变"),l("em",null,"纯函数:")],-1),w=l("blockquote",null,[l("p",null,"纯函数的意思是说，一个函数的返回结果的变化只依赖其参数，并且执行过程中没有副作用。 也就是说打铁还需自身硬，面对外界的复杂多变，我们要先保证函数封装的部分本身是稳固 的。比如前面消费税计算器的例子，当输入的产品价格参数为 100 时，输出的结果永远是 5。无论有什么干扰，它都不会返回一个不是 5 的数字，除非你换一个参数。")],-1),M=l("p",null,[l("em",null,"不可变：")],-1),N=l("blockquote",null,[l("p",null,"不可变就是在减少程序被外界影响的同时，也减少对外界的影响。因为如果你把一个外 部变量作为参数作为输入，在函数里做了改变，作为输出返回。那么这个过程中，你可能不知道这种变化会对整个系统造成什么样的结果。")],-1),T={id:"_2-状态的拷贝",tabindex:"-1"},x=l("p",null,"所以到这里，我们可以发现，针对原始类型的数据，无需过度担忧值的不可变。",-1),V=l("p",null,"不过，既然应用是“活”的，就可能会有“一系列”状态。我们通常需要通过诸如数组、对象类的数据结构，来保存“一系列”状态，那么在面对这一类的数据时，我们如何做到遵循不可变的原则呢？",-1),Y={id:"_2-1如何通过拷贝管理状态？",tabindex:"-1"},Z=l("p",null,[s("可以通过"),l("strong",null,"拷贝+更新"),s("的方式,也就是通过浅拷贝（见...用法）将数组或者对象的值赋给新的元素，保证不影响原来的值，一般的数据和对象是比较容易拷贝的，相对而言闭包会更难拷贝")],-1),O={id:"_2-2如何解决性能问题？",tabindex:"-1"},R=l("p",null,[s("从上面的例子中，我们可以看到通过对状态的拷贝，是可以做到不可变，不过随之而来的就是性能问题。 如果这个值只改变一两次，那就没问题。但假设我们的系统中有值不停在改变，如果每次都拷贝的话，就会占据大量内存。这样一来，我们应该如何处理呢？ 实际上，在这种情况下，有一个解决方案就是用到一个类似链表的结构，当中有一组对象记录改变的指数和相关的值。 比如下面的 [3, 1, 0, 7] 这组数组中，我们把第 0 个值变成 2，第 3 个值变成 6，第 4 个值添加 1，形成了 [2, 1, 0, 6, 1]。那么如果我们只记录变化的话，就是 0:2、3:6 和 4:1 这三组对象，是不是就减少了很多内存占用？ "),l("img",{src:"https://cdn.jsdelivr.net/gh/FlyingFish1314/chartbed/20230318222734.png",alt:""}),s(" 其实目前在市面上，已经有很多成熟的三方库比如 immutable.js，它们会有自己的数据结构，比如 array list 和 object map，以及相关算法来解决类似的问题了。")],-1),U={id:"_3-性能上的考虑",tabindex:"-1"},I=l("p",null,[s("我们接着再来看看性能上的考虑。 从性能的角度来讲，对象的内存和运算通常要优于闭包。比如，在下面第一个闭包的例子中，我们每次使用都会创建一个新的函数表达。 如何解决拷贝性能问题？ 而第二个对象的例子中，我们通过 "),l("code",null,"bind "),s("将 "),l("code",null,"this"),s(" 绑定到 "),l("code",null,"greetings2"),s(" 上，这样一来，PrintMessageB 就会引用 "),l("code",null,"greetings2.name"),s(" 来作为 "),l("code",null,"this.name"),s("，从而达到和闭包一样的效果。但我们不需要创建一个闭包，只需要将 "),l("code",null,"this"),s(" 指向引用的对象即可。")],-1),L=l("div",{class:"language-JavaScript"},[l("span",{class:"copy"}),l("pre",{class:"shiki material-theme-palenight",tabindex:"0"},[l("code",null,[l("span",{class:"line"},[l("span",{style:{color:"#676E95","font-style":"italic"}},"//  闭包")]),s(`
`),l("span",{class:"line"},[l("span",{style:{color:"#C792EA"}},"function"),l("span",{style:{color:"#A6ACCD"}}," "),l("span",{style:{color:"#82AAFF"}},"PrintMessageA"),l("span",{style:{color:"#89DDFF"}},"("),l("span",{style:{color:"#A6ACCD","font-style":"italic"}},"name"),l("span",{style:{color:"#89DDFF"}},")"),l("span",{style:{color:"#A6ACCD"}}," "),l("span",{style:{color:"#89DDFF"}},"{")]),s(`
`),l("span",{class:"line"},[l("span",{style:{color:"#89DDFF","font-style":"italic"}},"return"),l("span",{style:{color:"#F07178"}}," "),l("span",{style:{color:"#C792EA"}},"function"),l("span",{style:{color:"#F07178"}}," "),l("span",{style:{color:"#82AAFF"}},"printName"),l("span",{style:{color:"#89DDFF"}},"(){")]),s(`
`),l("span",{class:"line"},[l("span",{style:{color:"#89DDFF","font-style":"italic"}},"return"),l("span",{style:{color:"#F07178"}}," "),l("span",{style:{color:"#89DDFF"}},"`${"),l("span",{style:{color:"#A6ACCD"}},"name"),l("span",{style:{color:"#89DDFF"}},"}"),l("span",{style:{color:"#C3E88D"}},", 你好！"),l("span",{style:{color:"#89DDFF"}},"`"),l("span",{style:{color:"#89DDFF"}},";")]),s(`
`),l("span",{class:"line"},[l("span",{style:{color:"#89DDFF"}},"};")]),s(`
`),l("span",{class:"line"},[l("span",{style:{color:"#89DDFF"}},"}")]),s(`
`),l("span",{class:"line"},[l("span",{style:{color:"#C792EA"}},"var"),l("span",{style:{color:"#A6ACCD"}}," greetings1 "),l("span",{style:{color:"#89DDFF"}},"="),l("span",{style:{color:"#A6ACCD"}}," "),l("span",{style:{color:"#82AAFF"}},"PrintMessageA"),l("span",{style:{color:"#A6ACCD"}},"( "),l("span",{style:{color:"#89DDFF"}},'"'),l("span",{style:{color:"#C3E88D"}},"先生"),l("span",{style:{color:"#89DDFF"}},'"'),l("span",{style:{color:"#A6ACCD"}}," )"),l("span",{style:{color:"#89DDFF"}},";")]),s(`
`),l("span",{class:"line"},[l("span",{style:{color:"#82AAFF"}},"greetings1"),l("span",{style:{color:"#A6ACCD"}},"()"),l("span",{style:{color:"#89DDFF"}},";"),l("span",{style:{color:"#A6ACCD"}}," "),l("span",{style:{color:"#676E95","font-style":"italic"}},"// 先生，你好！")]),s(`
`),l("span",{class:"line"}),s(`
`),l("span",{class:"line"},[l("span",{style:{color:"#676E95","font-style":"italic"}},"// 对象")]),s(`
`),l("span",{class:"line"},[l("span",{style:{color:"#C792EA"}},"function"),l("span",{style:{color:"#A6ACCD"}}," "),l("span",{style:{color:"#82AAFF"}},"PrintMessageB"),l("span",{style:{color:"#89DDFF"}},"(){")]),s(`
`),l("span",{class:"line"},[l("span",{style:{color:"#89DDFF","font-style":"italic"}},"return"),l("span",{style:{color:"#F07178"}}," "),l("span",{style:{color:"#89DDFF"}},"`${"),l("span",{style:{color:"#89DDFF"}},"this."),l("span",{style:{color:"#A6ACCD"}},"name"),l("span",{style:{color:"#89DDFF"}},"}"),l("span",{style:{color:"#C3E88D"}},", 你好！"),l("span",{style:{color:"#89DDFF"}},"`"),l("span",{style:{color:"#89DDFF"}},";")]),s(`
`),l("span",{class:"line"},[l("span",{style:{color:"#89DDFF"}},"}")]),s(`
`),l("span",{class:"line"},[l("span",{style:{color:"#C792EA"}},"var"),l("span",{style:{color:"#A6ACCD"}}," greetings2 "),l("span",{style:{color:"#89DDFF"}},"="),l("span",{style:{color:"#A6ACCD"}}," PrintMessageB"),l("span",{style:{color:"#89DDFF"}},"."),l("span",{style:{color:"#82AAFF"}},"bind"),l("span",{style:{color:"#A6ACCD"}},"( "),l("span",{style:{color:"#89DDFF"}},"{")]),s(`
`),l("span",{class:"line"},[l("span",{style:{color:"#F07178"}},"name"),l("span",{style:{color:"#89DDFF"}},":"),l("span",{style:{color:"#A6ACCD"}}," "),l("span",{style:{color:"#89DDFF"}},'"'),l("span",{style:{color:"#C3E88D"}},"先生"),l("span",{style:{color:"#89DDFF"}},'"')]),s(`
`),l("span",{class:"line"},[l("span",{style:{color:"#89DDFF"}},"}"),l("span",{style:{color:"#A6ACCD"}}," )"),l("span",{style:{color:"#89DDFF"}},";")]),s(`
`),l("span",{class:"line"},[l("span",{style:{color:"#82AAFF"}},"greetings2"),l("span",{style:{color:"#A6ACCD"}},"()"),l("span",{style:{color:"#89DDFF"}},";"),l("span",{style:{color:"#A6ACCD"}}," "),l("span",{style:{color:"#676E95","font-style":"italic"}},"// 先生，你好！")]),s(`
`),l("span",{class:"line"}),s(`
`),l("span",{class:"line"})])])],-1),z={id:"总结",tabindex:"-1"},G=l("p",null,"这节课，我们一起深入理解了函数式编程中的不可变。我们需要重点关注的，就是对象和闭包在处理不可变问题上的不同优势。",-1),H=l("blockquote",null,[l("p",null,"在属性和方法的隐私方面，闭包天然对属性有保护作用，同时它也可以按需暴露接口，来更细粒度地获取或重新给状态赋值。但是它和我们要解决的问题，似乎关系不大。 而对象不仅可以轻松做到 props 整体不可变，而且在需要 state 变化时，在拷贝上也更有优势。不过从性能的角度来看，如果拷贝的量不大，也许它们的性能差不多，但如果是一个高频交互的界面，微小的差别可能就会被放大。")],-1),K=l("p",null,"所以总结起来，在 React.js 中，它选择使用对象作为 props 和 state 的值类型，能更容易保证属性和状态值的整体不可变；而且面对状态的变化，它也更容易拷贝；在处理高频交互时，它的性能也会更好。",-1),Q=l("p",null,"而闭包虽然有隐私上的优势和更细粒度的操作，可是在应用交互和状态管理这个场景下，它并没有什么实际的作用。所以，有利于使用对象的条件会相对多一些。",-1),W=l("p",null,[s("最后，你也可以再来复习下这两种方式的优劣势。其实，基于 React.js 的例子，你可以发现，不同的数据类型和处理变与不变的方式，并没有绝对的好与不好，而是需要根据具体情况，来确定哪种方式更适合你的程序和应用所需要支持的场景。 "),l("img",{src:"https://cdn.jsdelivr.net/gh/FlyingFish1314/chartbed/%E9%97%AD%E5%8C%85%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83.png",alt:""})],-1),X={id:"相关拓展",tabindex:"-1"},ll=l("ul",null,[l("li",null,"闭包是带数据的行为，对象是带行为的数据")],-1);function sl(n,el,nl,tl,i,ol){const o=_,c=p;return h(),u(c,{frontmatter:i.frontmatter,data:i.data},{"main-content-md":e(()=>[l("h2",F,[s("1.闭包（closure）和对象 "),a(o,{class:"header-anchor",href:"#_1-闭包（closure）和对象","aria-hidden":"true"},{default:e(()=>[s("#")]),_:1})]),m,f,l("h3",g,[s("闭包的描述 "),a(o,{class:"header-anchor",href:"#闭包的描述","aria-hidden":"true"},{default:e(()=>[s("#")]),_:1})]),A,C,v,b,E,k,$,J,l("h4",S,[s("1.属性的修改---隐私(privacy) "),a(o,{class:"header-anchor",href:"#_1-属性的修改-隐私-privacy","aria-hidden":"true"},{default:e(()=>[s("#")]),_:1})]),B,j,P,q,w,M,N,l("h4",T,[s("2.状态的拷贝 "),a(o,{class:"header-anchor",href:"#_2-状态的拷贝","aria-hidden":"true"},{default:e(()=>[s("#")]),_:1})]),x,V,l("h5",Y,[s("2.1如何通过拷贝管理状态？ "),a(o,{class:"header-anchor",href:"#_2-1如何通过拷贝管理状态？","aria-hidden":"true"},{default:e(()=>[s("#")]),_:1})]),Z,l("h5",O,[s("2.2如何解决性能问题？ "),a(o,{class:"header-anchor",href:"#_2-2如何解决性能问题？","aria-hidden":"true"},{default:e(()=>[s("#")]),_:1})]),R,l("h4",U,[s("3.性能上的考虑 "),a(o,{class:"header-anchor",href:"#_3-性能上的考虑","aria-hidden":"true"},{default:e(()=>[s("#")]),_:1})]),I,L,l("h3",z,[s("总结 "),a(o,{class:"header-anchor",href:"#总结","aria-hidden":"true"},{default:e(()=>[s("#")]),_:1})]),G,H,K,Q,W,l("h3",X,[s("相关拓展 "),a(o,{class:"header-anchor",href:"#相关拓展","aria-hidden":"true"},{default:e(()=>[s("#")]),_:1})]),ll]),"main-header":e(()=>[t(n.$slots,"main-header")]),"main-header-after":e(()=>[t(n.$slots,"main-header-after")]),"main-nav":e(()=>[t(n.$slots,"main-nav")]),"main-content":e(()=>[t(n.$slots,"main-content")]),"main-content-after":e(()=>[t(n.$slots,"main-content-after")]),"main-nav-before":e(()=>[t(n.$slots,"main-nav-before")]),"main-nav-after":e(()=>[t(n.$slots,"main-nav-after")]),comment:e(()=>[t(n.$slots,"comment")]),footer:e(()=>[t(n.$slots,"footer")]),aside:e(()=>[t(n.$slots,"aside")]),"aside-custom":e(()=>[t(n.$slots,"aside-custom")]),default:e(()=>[t(n.$slots,"default")]),_:3},8,["frontmatter","data"])}const ul=d(D,[["render",sl]]);export{dl as __pageData,ul as default};
